{"version":3,"file":"index.js","sourceRoot":"","sources":["index.ts"],"names":[],"mappings":";AAIA,MAAM,UAAU,GAAG,yBAAyB,CAAC;AAM7C,MAAM,uBAAuB;IAWzB,YAAmB,UAA0C,EAAE;QAC3D,IAAI,CAAC,OAAO,mCAAO,uBAAuB,CAAC,cAAc,GAAK,OAAO,CAAC,CAAC;IAC3E,CAAC;IAEM,KAAK,CAAC,QAAkB;QAC3B,MAAM,MAAM,GAAG,QAAQ,CAAC,UAAU,CAAC,MAAM,CAAC,CAAC;QAC3C,KAAK,MAAM,SAAS,IAAI,CAAC,KAAK,EAAE,MAAM,CAAC,EAAE;YACrC,QAAQ;iBACH,OAAO,CAAC,UAAU,CAAC;iBACnB,QAAQ,CAAC,UAAU,EAAE,CAAC,OAAO,EAAE,cAAc,EAAE,QAAQ,EAAE,EAAE;;gBACxD,IACI,OAAO,OAAO,CAAC,IAAI,KAAK,QAAQ;oBAChC,CAAC,CAAC,CAAC,MAAA,IAAI,CAAC,OAAO,CAAC,kBAAkB,mCAAI,KAAK,CAAC;wBACxC,OAAO,CAAC,IAAI,CAAC,KAAK,CAAC,iCAAiC,CAAC,IAAI,IAAI,CAAC,EACpE;oBACE,QAAQ,EAAE,CAAC;oBACX,OAAO;iBACV;gBAED,MAAM,IAAI,GAAG,OAAO,CAAC,IAAI,CAAC,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC,CAAC;gBACzD,IAAI,IAAI,KAAK,OAAO,CAAC,IAAI,EAAE;oBACvB,QAAQ,EAAE,CAAC;iBACd;qBAAM;oBACH,QAAQ,CAAC,SAAS,CACd,MAAM,kCAEC,OAAO,KACV,IAAI,EACJ,YAAY,EAAE,MAAA,OAAO,CAAC,YAAY,0CAAE,OAAO,CAAC,UAAU,EAAE,SAAS,CAAC,KAEtE,eAAe,IAAI,EAAE,EACrB,cAAc,EACd,QAAQ,CACX,CAAC;iBACL;YACL,CAAC,CAAC,CAAC;SACV;IACL,CAAC;;AA/CD;8BAC8B;AAChB,+BAAO,GAAG,uBAAuB,CAAC;AAExB,sCAAc,GAAmC;IACrE,kBAAkB,EAAE,KAAK;CAC5B,CAAC;AA4CN,iBAAS,uBAAuB,CAAC","sourcesContent":["import type {ResolveOptions} from \"webpack\";\n\ntype Resolver = NonNullable<ResolveOptions[\"resolver\"]>;\n\nconst pluginName = \"ResolveTypescriptPlugin\";\n\ninterface ResolveTypescriptPluginOptions {\n    includeNodeModules?: boolean;\n}\n\nclass ResolveTypescriptPlugin {\n    /** @deprecated For backwards compatibility with versions < v1.1.2.\n     * Will be removed in v2.0. */\n    public static default = ResolveTypescriptPlugin;\n\n    private static readonly defaultOptions: ResolveTypescriptPluginOptions = {\n        includeNodeModules: false\n    };\n\n    private readonly options: ResolveTypescriptPluginOptions;\n\n    public constructor(options: ResolveTypescriptPluginOptions = {}) {\n        this.options = {...ResolveTypescriptPlugin.defaultOptions, ...options};\n    }\n\n    public apply(resolver: Resolver): void {\n        const target = resolver.ensureHook(\"file\");\n        for (const extension of [\".ts\", \".tsx\"]) {\n            resolver\n                .getHook(\"raw-file\")\n                .tapAsync(pluginName, (request, resolveContext, callback) => {\n                    if (\n                        typeof request.path !== \"string\" ||\n                        (!(this.options.includeNodeModules ?? false) &&\n                            request.path.match(/(^|[\\\\/])node_modules($|[\\\\/])/u) != null)\n                    ) {\n                        callback();\n                        return;\n                    }\n\n                    const path = request.path.replace(/\\.jsx?$/u, extension);\n                    if (path === request.path) {\n                        callback();\n                    } else {\n                        resolver.doResolve(\n                            target,\n                            {\n                                ...request,\n                                path,\n                                relativePath: request.relativePath?.replace(/\\.jsx?$/u, extension)\n                            },\n                            `using path: ${path}`,\n                            resolveContext,\n                            callback\n                        );\n                    }\n                });\n        }\n    }\n}\n\nexport = ResolveTypescriptPlugin;\n"]}