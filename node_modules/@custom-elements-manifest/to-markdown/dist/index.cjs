var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[Object.keys(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  __markAsModule(target);
  for (var name in all2)
    __defProp(target, name, { get: all2[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};

// ../../node_modules/mdast-builder/lib/src/index.js
var require_src = __commonJS({
  "../../node_modules/mdast-builder/lib/src/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function normalizeChildren(children) {
      if (Array.isArray(children)) {
        return children;
      } else if (typeof children === "function") {
        const res = children();
        return normalizeChildren(res);
      } else if (typeof children === "undefined") {
        return [];
      } else {
        return [children];
      }
    }
    var valueNode = (type, value) => ({
      type,
      value
    });
    var nodeWithChildren = (type, kids) => ({
      type,
      children: normalizeChildren(kids)
    });
    exports.text = (value) => valueNode("text", value);
    exports.inlineCode = (value) => valueNode("inlineCode", value);
    exports.html = (value) => valueNode("html", value);
    exports.strong = (kids) => nodeWithChildren("strong", kids);
    exports.emphasis = (kids) => nodeWithChildren("emphasis", kids);
    exports.strike = (kids) => nodeWithChildren("delete", kids);
    exports.tableCell = (kids) => nodeWithChildren("tableCell", kids);
    exports.tableRow = (kids) => nodeWithChildren("tableRow", kids);
    exports.table = (align, kids) => Object.assign({}, nodeWithChildren("table", kids), { align });
    exports.brk = Object.freeze({ type: "break" });
    exports.separator = exports.text("---");
    exports.link = (url, title = "", kids) => Object.assign({}, nodeWithChildren("link", kids), {
      url,
      title
    });
    exports.root = (kids) => nodeWithChildren("root", kids);
    exports.rootWithTitle = (depth, title, kids) => {
      return exports.root([exports.heading(depth, title), ...normalizeChildren(kids)]);
    };
    exports.paragraph = (kids) => nodeWithChildren("paragraph", kids);
    exports.image = (url, title, alt, kids) => Object.assign({}, nodeWithChildren("image", kids), { url, title, alt });
    exports.blockquote = (kids) => nodeWithChildren("blockquote", kids);
    exports.code = (lang, value) => Object.assign({}, valueNode("code", value), { lang });
    exports.heading = (depth, kids) => {
      if (depth < 1)
        throw new Error(`Invalid depth: ${depth}`);
      return Object.assign({}, nodeWithChildren("heading", kids), { depth });
    };
    exports.list = (ordered, kids) => Object.assign({}, nodeWithChildren("list", kids), { ordered: ordered === "ordered" });
    exports.listItem = (kids) => nodeWithChildren("listItem", kids);
  }
});

// index.js
__export(exports, {
  customElementsManifestToMarkdown: () => customElementsManifestToMarkdown
});
var import_mdast_builder2 = __toModule(require_src());

// lib/fp.js
var compose = (...fns) => fns.reduce((f, g) => (...args) => f(g(...args)));
var identity = (x) => x;
var not = (p) => (x) => !p(x);
var and = (p, q) => (x) => p(x) && q(x);
var or = (p, q) => (x) => p(x) || q(x);
var length = (x) => x?.length ?? 0;
var privacy = (x) => x?.privacy;
var kind = (x) => x?.kind;
var isSame = (test) => (x) => x === test;
var isStatic = (x) => x?.static ?? false;
var isPrivate = compose(isSame("private"), privacy);
var isProtected = compose(isSame("protected"), privacy);
var isClass = compose(isSame("class"), privacy);
var isMixin = compose(isSame("mixin"), privacy);
var isLengthy = compose((x) => !!x, length);
var isClassLike = or(isClass, isMixin);
var kindIs = (test) => compose(isSame(test), kind);
var repeat = (length2, x) => Array.from({ length: length2 }, () => x);
var capital = (x) => typeof x !== "string" ? x : x.trim().replace(/^\w/, (c) => c.toUpperCase());
var isDefined = (value) => value != null;

// lib/cells.js
var import_mdast_builder = __toModule(require_src());
var formatParam = (param) => `${param?.name}${param?.type?.text ? `: ${param.type.text}` : ""}`;
var formatParameters = (x) => x?.parameters?.map(formatParam).join(", ");
function getExportKind(x, options) {
  const configured = options?.exportKinds?.[x.kind];
  if (configured?.url)
    return (0, import_mdast_builder.image)(configured.url, null, x.kind);
  else if (typeof configured === "string")
    return (0, import_mdast_builder.text)(configured);
  else
    return x.kind ? (0, import_mdast_builder.inlineCode)(x.kind) : (0, import_mdast_builder.text)("");
}
var DECLARATION = { heading: "Declaration", get: (x) => x.declaration?.name ?? "" };
var DEFAULT = { heading: "Default", get: (x) => x.default, cellType: import_mdast_builder.inlineCode };
var NAME = { heading: "Name", get: (x) => x.name, cellType: import_mdast_builder.inlineCode };
var ATTR_FIELD = { heading: "Field", get: (x) => x.fieldName };
var INHERITANCE = { heading: "Inherited From", get: (x) => x.inheritedFrom?.name ?? "" };
var MODULE = { heading: "Module", get: (x) => x.declaration?.module ?? "" };
var PACKAGE = { heading: "Package", get: (x) => x.declaration?.package ?? "" };
var PARAMETERS = { heading: "Parameters", get: formatParameters, cellType: import_mdast_builder.inlineCode };
var RETURN = { heading: "Return", get: (x) => x.return?.type?.text ?? x.return, cellType: import_mdast_builder.inlineCode };
var TYPE = { heading: "Type", get: (x) => x.type?.text ?? "", cellType: import_mdast_builder.inlineCode };
var EXPORT_KIND = { heading: "Kind", get: getExportKind, cellType: "raw" };

// node_modules/zwitch/index.js
var own = {}.hasOwnProperty;
function zwitch(key, options) {
  var settings = options || {};
  function one2(value) {
    var fn = one2.invalid;
    var handlers = one2.handlers;
    if (value && own.call(value, key)) {
      fn = own.call(handlers, value[key]) ? handlers[value[key]] : one2.unknown;
    }
    if (fn) {
      return fn.apply(this, arguments);
    }
  }
  one2.handlers = settings.handlers || {};
  one2.invalid = settings.invalid;
  one2.unknown = settings.unknown;
  return one2;
}

// node_modules/mdast-util-to-markdown/lib/configure.js
function configure(base, extension) {
  let index = -1;
  let key;
  if (extension.extensions) {
    while (++index < extension.extensions.length) {
      configure(base, extension.extensions[index]);
    }
  }
  for (key in extension) {
    if (key === "extensions") {
    } else if (key === "unsafe" || key === "join") {
      base[key] = [...base[key] || [], ...extension[key] || []];
    } else if (key === "handlers") {
      base[key] = Object.assign(base[key], extension[key] || {});
    } else {
      base.options[key] = extension[key];
    }
  }
  return base;
}

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, context) {
  const children = parent.children || [];
  const results = [];
  let index = -1;
  while (++index < children.length) {
    const child = children[index];
    results.push(context.handle(child, parent, context, { before: "\n", after: "\n" }));
    if (index < children.length - 1) {
      results.push(between(child, children[index + 1]));
    }
  }
  return results.join("");
  function between(left, right) {
    let index2 = context.join.length;
    let result;
    while (index2--) {
      result = context.join[index2](left, right, parent, context);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
}

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol = /\r?\n|\r/g;
function indentLines(value, map3) {
  const result = [];
  let start = 0;
  let line2 = 0;
  let match;
  while (match = eol.exec(value)) {
    one2(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line2++;
  }
  one2(value.slice(start));
  return result.join("");
  function one2(value2) {
    result.push(map3(value2, line2, !value2));
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node, _, context) {
  const exit = context.enter("blockquote");
  const value = indentLines(containerFlow(node, context), map);
  exit();
  return value;
}
function map(line2, _, blank) {
  return ">" + (blank ? "" : " ") + line2;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
  return listInScope(stack, pattern.inConstruct, true) && !listInScope(stack, pattern.notInConstruct, false);
}
function listInScope(stack, list2, none) {
  if (!list2) {
    return none;
  }
  if (typeof list2 === "string") {
    list2 = [list2];
  }
  let index = -1;
  while (++index < list2.length) {
    if (stack.includes(list2[index])) {
      return true;
    }
  }
  return false;
}

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, context, safe2) {
  let index = -1;
  while (++index < context.unsafe.length) {
    if (context.unsafe[index].character === "\n" && patternInScope(context.stack, context.unsafe[index])) {
      return /[ \t]/.test(safe2.before) ? "" : " ";
    }
  }
  return "\\\n";
}

// node_modules/longest-streak/index.js
function longestStreak(value, character) {
  var source = String(value);
  var index = source.indexOf(character);
  var expected = index;
  var count = 0;
  var max = 0;
  if (typeof character !== "string" || character.length !== 1) {
    throw new Error("Expected character");
  }
  while (index !== -1) {
    if (index === expected) {
      if (++count > max) {
        max = count;
      }
    } else {
      count = 1;
    }
    expected = index + 1;
    index = source.indexOf(character, expected);
  }
  return max;
}

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node, context) {
  return Boolean(!context.options.fences && node.value && !node.lang && /[^ \r\n]/.test(node.value) && !/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value));
}

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(context) {
  const marker = context.options.fence || "`";
  if (marker !== "`" && marker !== "~") {
    throw new Error("Cannot serialize code with `" + marker + "` for `options.fence`, expected `` ` `` or `~`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
function patternCompile(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""), "g");
  }
  return pattern._compiled;
}

// node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(context, input, config) {
  const value = (config.before || "") + (input || "") + (config.after || "");
  const positions = [];
  const result = [];
  const infos = {};
  let index = -1;
  while (++index < context.unsafe.length) {
    const pattern = context.unsafe[index];
    if (!patternInScope(context.stack, pattern)) {
      continue;
    }
    const expression = patternCompile(pattern);
    let match;
    while (match = expression.exec(value)) {
      const before = "before" in pattern || Boolean(pattern.atBreak);
      const after = "after" in pattern;
      const position = match.index + (before ? match[1].length : 0);
      if (positions.includes(position)) {
        if (infos[position].before && !before) {
          infos[position].before = false;
        }
        if (infos[position].after && !after) {
          infos[position].after = false;
        }
      } else {
        positions.push(position);
        infos[position] = { before, after };
      }
    }
  }
  positions.sort(numerical);
  let start = config.before ? config.before.length : 0;
  const end = value.length - (config.after ? config.after.length : 0);
  index = -1;
  while (++index < positions.length) {
    const position = positions[index];
    if (position < start || position >= end) {
      continue;
    }
    if (position + 1 < end && positions[index + 1] === position + 1 && infos[position].after && !infos[position + 1].before && !infos[position + 1].after) {
      continue;
    }
    if (start !== position) {
      result.push(escapeBackslashes(value.slice(start, position), "\\"));
    }
    start = position;
    if (/[!-/:-@[-`{-~]/.test(value.charAt(position)) && (!config.encode || !config.encode.includes(value.charAt(position)))) {
      result.push("\\");
    } else {
      result.push("&#x" + value.charCodeAt(position).toString(16).toUpperCase() + ";");
      start++;
    }
  }
  result.push(escapeBackslashes(value.slice(start, end), config.after));
  return result.join("");
}
function numerical(a, b) {
  return a - b;
}
function escapeBackslashes(value, after) {
  const expression = /\\(?=[!-/:-@[-`{-~])/g;
  const positions = [];
  const results = [];
  const whole = value + after;
  let index = -1;
  let start = 0;
  let match;
  while (match = expression.exec(whole)) {
    positions.push(match.index);
  }
  while (++index < positions.length) {
    if (start !== positions[index]) {
      results.push(value.slice(start, positions[index]));
    }
    results.push("\\");
    start = positions[index];
  }
  results.push(value.slice(start));
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node, _, context) {
  const marker = checkFence(context);
  const raw = node.value || "";
  const suffix = marker === "`" ? "GraveAccent" : "Tilde";
  let value;
  let exit;
  if (formatCodeAsIndented(node, context)) {
    exit = context.enter("codeIndented");
    value = indentLines(raw, map2);
  } else {
    const sequence = marker.repeat(Math.max(longestStreak(raw, marker) + 1, 3));
    let subexit;
    exit = context.enter("codeFenced");
    value = sequence;
    if (node.lang) {
      subexit = context.enter("codeFencedLang" + suffix);
      value += safe(context, node.lang, {
        before: "`",
        after: " ",
        encode: ["`"]
      });
      subexit();
    }
    if (node.lang && node.meta) {
      subexit = context.enter("codeFencedMeta" + suffix);
      value += " " + safe(context, node.meta, {
        before: " ",
        after: "\n",
        encode: ["`"]
      });
      subexit();
    }
    value += "\n";
    if (raw) {
      value += raw + "\n";
    }
    value += sequence;
  }
  exit();
  return value;
}
function map2(line2, _, blank) {
  return (blank ? "" : "    ") + line2;
}

// ../../node_modules/parse-entities/decode-entity.browser.js
var semicolon = 59;
var element;
function decodeEntity(characters) {
  var entity = "&" + characters + ";";
  var char;
  element = element || document.createElement("i");
  element.innerHTML = entity;
  char = element.textContent;
  if (char.charCodeAt(char.length - 1) === semicolon && characters !== "semi") {
    return false;
  }
  return char === entity ? false : char;
}

// node_modules/mdast-util-to-markdown/lib/util/association.js
var characterEscape = /\\([!-/:-@[-`{-~])/g;
var characterReference = /&(#(\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
function association(node) {
  if (node.label || !node.identifier) {
    return node.label || "";
  }
  return node.identifier.replace(characterEscape, "$1").replace(characterReference, decodeIfPossible);
}
function decodeIfPossible($0, $1) {
  return decodeEntity($1) || $0;
}

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(context) {
  const marker = context.options.quote || '"';
  if (marker !== '"' && marker !== "'") {
    throw new Error("Cannot serialize title with `" + marker + "` for `options.quote`, expected `\"`, or `'`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition(node, _, context) {
  const marker = checkQuote(context);
  const suffix = marker === '"' ? "Quote" : "Apostrophe";
  const exit = context.enter("definition");
  let subexit = context.enter("label");
  let value = "[" + safe(context, association(node), { before: "[", after: "]" }) + "]: ";
  subexit();
  if (!node.url || /[ \t\r\n]/.test(node.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe(context, node.url, { before: " ", after: " " });
  }
  subexit();
  if (node.title) {
    subexit = context.enter("title" + suffix);
    value += " " + marker + safe(context, node.title, { before: marker, after: marker }) + marker;
    subexit();
  }
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(context) {
  const marker = context.options.emphasis || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize emphasis with `" + marker + "` for `options.emphasis`, expected `*`, or `_`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, context, safeOptions) {
  const children = parent.children || [];
  const results = [];
  let index = -1;
  let before = safeOptions.before;
  while (++index < children.length) {
    const child = children[index];
    let after;
    if (index + 1 < children.length) {
      let handle2 = context.handle.handlers[children[index + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index + 1], parent, context, {
        before: "",
        after: ""
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
    }
    results.push(context.handle(child, parent, context, { before, after }));
    before = results[results.length - 1].slice(-1);
  }
  return results.join("");
}

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
emphasis.peek = emphasisPeek;
function emphasis(node, _, context) {
  const marker = checkEmphasis(context);
  const exit = context.enter("emphasis");
  const value = containerPhrasing(node, context, {
    before: marker,
    after: marker
  });
  exit();
  return marker + value + marker;
}
function emphasisPeek(_, _1, context) {
  return context.options.emphasis || "*";
}

// node_modules/mdast-util-to-string/index.js
function toString(node, options) {
  var { includeImageAlt = true } = options || {};
  return one(node, includeImageAlt);
}
function one(node, includeImageAlt) {
  return node && typeof node === "object" && (node.value || (includeImageAlt ? node.alt : "") || "children" in node && all(node.children, includeImageAlt) || Array.isArray(node) && all(node, includeImageAlt)) || "";
}
function all(values, includeImageAlt) {
  var result = [];
  var index = -1;
  while (++index < values.length) {
    result[index] = one(values[index], includeImageAlt);
  }
  return result.join("");
}

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node, context) {
  return Boolean(context.options.setext && (!node.depth || node.depth < 3) && toString(node));
}

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node, _, context) {
  const rank = Math.max(Math.min(6, node.depth || 1), 1);
  let exit;
  let subexit;
  let value;
  if (formatHeadingAsSetext(node, context)) {
    exit = context.enter("headingSetext");
    subexit = context.enter("phrasing");
    value = containerPhrasing(node, context, { before: "\n", after: "\n" });
    subexit();
    exit();
    return value + "\n" + (rank === 1 ? "=" : "-").repeat(value.length - (Math.max(value.lastIndexOf("\r"), value.lastIndexOf("\n")) + 1));
  }
  const sequence = "#".repeat(rank);
  exit = context.enter("headingAtx");
  subexit = context.enter("phrasing");
  value = containerPhrasing(node, context, { before: "# ", after: "\n" });
  value = value ? sequence + " " + value : sequence;
  if (context.options.closeAtx) {
    value += " " + sequence;
  }
  subexit();
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/html.js
html.peek = htmlPeek;
function html(node) {
  return node.value || "";
}
function htmlPeek() {
  return "<";
}

// node_modules/mdast-util-to-markdown/lib/handle/image.js
image2.peek = imagePeek;
function image2(node, _, context) {
  const quote = checkQuote(context);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  const exit = context.enter("image");
  let subexit = context.enter("label");
  let value = "![" + safe(context, node.alt, { before: "[", after: "]" }) + "](";
  subexit();
  if (!node.url && node.title || /[ \t\r\n]/.test(node.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe(context, node.url, {
      before: "(",
      after: node.title ? " " : ")"
    });
  }
  subexit();
  if (node.title) {
    subexit = context.enter("title" + suffix);
    value += " " + quote + safe(context, node.title, { before: quote, after: quote }) + quote;
    subexit();
  }
  value += ")";
  exit();
  return value;
}
function imagePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
imageReference.peek = imageReferencePeek;
function imageReference(node, _, context) {
  const type = node.referenceType;
  const exit = context.enter("imageReference");
  let subexit = context.enter("label");
  const alt = safe(context, node.alt, { before: "[", after: "]" });
  let value = "![" + alt + "]";
  subexit();
  const stack = context.stack;
  context.stack = [];
  subexit = context.enter("reference");
  const reference = safe(context, association(node), { before: "[", after: "]" });
  subexit();
  context.stack = stack;
  exit();
  if (type === "full" || !alt || alt !== reference) {
    value += "[" + reference + "]";
  } else if (type !== "shortcut") {
    value += "[]";
  }
  return value;
}
function imageReferencePeek() {
  return "!";
}

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode2.peek = inlineCodePeek;
function inlineCode2(node, _, context) {
  let value = node.value || "";
  let sequence = "`";
  let index = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/[ \r\n`]/.test(value.charAt(0)) || /[ \r\n`]/.test(value.charAt(value.length - 1)))) {
    value = " " + value + " ";
  }
  while (++index < context.unsafe.length) {
    const pattern = context.unsafe[index];
    const expression = patternCompile(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position = match.index;
      if (value.charCodeAt(position) === 10 && value.charCodeAt(position - 1) === 13) {
        position--;
      }
      value = value.slice(0, position) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek() {
  return "`";
}

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node, context) {
  const raw = toString(node);
  return Boolean(!context.options.resourceLink && node.url && !node.title && node.children && node.children.length === 1 && node.children[0].type === "text" && (raw === node.url || "mailto:" + raw === node.url) && /^[a-z][a-z+.-]+:/i.test(node.url) && !/[\0- <>\u007F]/.test(node.url));
}

// node_modules/mdast-util-to-markdown/lib/handle/link.js
link.peek = linkPeek;
function link(node, _, context) {
  const quote = checkQuote(context);
  const suffix = quote === '"' ? "Quote" : "Apostrophe";
  let exit;
  let subexit;
  let value;
  if (formatLinkAsAutolink(node, context)) {
    const stack = context.stack;
    context.stack = [];
    exit = context.enter("autolink");
    value = "<" + containerPhrasing(node, context, { before: "<", after: ">" }) + ">";
    exit();
    context.stack = stack;
    return value;
  }
  exit = context.enter("link");
  subexit = context.enter("label");
  value = "[" + containerPhrasing(node, context, { before: "[", after: "]" }) + "](";
  subexit();
  if (!node.url && node.title || /[ \t\r\n]/.test(node.url)) {
    subexit = context.enter("destinationLiteral");
    value += "<" + safe(context, node.url, { before: "<", after: ">" }) + ">";
  } else {
    subexit = context.enter("destinationRaw");
    value += safe(context, node.url, {
      before: "(",
      after: node.title ? " " : ")"
    });
  }
  subexit();
  if (node.title) {
    subexit = context.enter("title" + suffix);
    value += " " + quote + safe(context, node.title, { before: quote, after: quote }) + quote;
    subexit();
  }
  value += ")";
  exit();
  return value;
}
function linkPeek(node, _, context) {
  return formatLinkAsAutolink(node, context) ? "<" : "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
linkReference.peek = linkReferencePeek;
function linkReference(node, _, context) {
  const type = node.referenceType;
  const exit = context.enter("linkReference");
  let subexit = context.enter("label");
  const text4 = containerPhrasing(node, context, { before: "[", after: "]" });
  let value = "[" + text4 + "]";
  subexit();
  const stack = context.stack;
  context.stack = [];
  subexit = context.enter("reference");
  const reference = safe(context, association(node), { before: "[", after: "]" });
  subexit();
  context.stack = stack;
  exit();
  if (type === "full" || !text4 || text4 !== reference) {
    value += "[" + reference + "]";
  } else if (type !== "shortcut") {
    value += "[]";
  }
  return value;
}
function linkReferencePeek() {
  return "[";
}

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list(node, _, context) {
  const exit = context.enter("list");
  const value = containerFlow(node, context);
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(context) {
  const marker = context.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(context) {
  const style = context.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  }
  return style;
}

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node, parent, context) {
  const listItemIndent = checkListItemIndent(context);
  let bullet = checkBullet(context);
  if (parent && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + ".";
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.spread || node.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const exit = context.enter("listItem");
  const value = indentLines(containerFlow(node, context), map3);
  exit();
  return value;
  function map3(line2, index, blank) {
    if (index) {
      return (blank ? "" : " ".repeat(size)) + line2;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
  }
}

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node, _, context) {
  const exit = context.enter("paragraph");
  const subexit = context.enter("phrasing");
  const value = containerPhrasing(node, context, { before: "\n", after: "\n" });
  subexit();
  exit();
  return value;
}

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node, _, context) {
  return containerFlow(node, context);
}

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(context) {
  const marker = context.options.strong || "*";
  if (marker !== "*" && marker !== "_") {
    throw new Error("Cannot serialize strong with `" + marker + "` for `options.strong`, expected `*`, or `_`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
strong.peek = strongPeek;
function strong(node, _, context) {
  const marker = checkStrong(context);
  const exit = context.enter("strong");
  const value = containerPhrasing(node, context, {
    before: marker,
    after: marker
  });
  exit();
  return marker + marker + value + marker + marker;
}
function strongPeek(_, _1, context) {
  return context.options.strong || "*";
}

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text2(node, _, context, safeOptions) {
  return safe(context, node.value, safeOptions);
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(context) {
  const repetition = context.options.ruleRepetition || 3;
  if (repetition < 3) {
    throw new Error("Cannot serialize rules with repetition `" + repetition + "` for `options.ruleRepetition`, expected `3` or more");
  }
  return repetition;
}

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(context) {
  const marker = context.options.rule || "*";
  if (marker !== "*" && marker !== "-" && marker !== "_") {
    throw new Error("Cannot serialize rules with `" + marker + "` for `options.rule`, expected `*`, `-`, or `_`");
  }
  return marker;
}

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak(_, _1, context) {
  const value = (checkRule(context) + (context.options.ruleSpaces ? " " : "")).repeat(checkRuleRepetition(context));
  return context.options.ruleSpaces ? value.slice(0, -1) : value;
}

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle = {
  blockquote,
  break: hardBreak,
  code,
  definition,
  emphasis,
  hardBreak,
  heading,
  html,
  image: image2,
  imageReference,
  inlineCode: inlineCode2,
  link,
  linkReference,
  list,
  listItem,
  paragraph,
  root,
  strong,
  text: text2,
  thematicBreak
};

// node_modules/mdast-util-to-markdown/lib/join.js
var join = [joinDefaults];
function joinDefaults(left, right, parent, context) {
  if (right.type === "list" && right.type === left.type && Boolean(left.ordered) === Boolean(right.ordered) || right.type === "code" && formatCodeAsIndented(right, context) && (left.type === "list" || left.type === right.type && formatCodeAsIndented(left, context))) {
    return false;
  }
  if (typeof parent.spread === "boolean") {
    if (left.type === "paragraph" && (left.type === right.type || right.type === "definition" || right.type === "heading" && formatHeadingAsSetext(right, context))) {
      return;
    }
    return parent.spread ? 1 : 0;
  }
}

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var unsafe = [
  {
    character: "	",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  {
    character: "\r",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: "\n",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedLangTilde",
      "codeFencedMetaGraveAccent",
      "codeFencedMetaTilde",
      "destinationLiteral",
      "headingAtx"
    ]
  },
  {
    character: " ",
    inConstruct: ["codeFencedLangGraveAccent", "codeFencedLangTilde"]
  },
  { character: "!", after: "\\[", inConstruct: "phrasing" },
  { character: '"', inConstruct: "titleQuote" },
  { atBreak: true, character: "#" },
  { character: "#", inConstruct: "headingAtx", after: "(?:[\r\n]|$)" },
  { character: "&", after: "[#A-Za-z]", inConstruct: "phrasing" },
  { character: "'", inConstruct: "titleApostrophe" },
  { character: "(", inConstruct: "destinationRaw" },
  { before: "\\]", character: "(", inConstruct: "phrasing" },
  { atBreak: true, before: "\\d+", character: ")" },
  { character: ")", inConstruct: "destinationRaw" },
  { atBreak: true, character: "*" },
  { character: "*", inConstruct: "phrasing" },
  { atBreak: true, character: "+" },
  { atBreak: true, character: "-" },
  { atBreak: true, before: "\\d+", character: ".", after: "(?:[ 	\r\n]|$)" },
  { atBreak: true, character: "<", after: "[!/?A-Za-z]" },
  { character: "<", after: "[!/?A-Za-z]", inConstruct: "phrasing" },
  { character: "<", inConstruct: "destinationLiteral" },
  { atBreak: true, character: "=" },
  { atBreak: true, character: ">" },
  { character: ">", inConstruct: "destinationLiteral" },
  { atBreak: true, character: "[" },
  { character: "[", inConstruct: ["phrasing", "label", "reference"] },
  { character: "\\", after: "[\\r\\n]", inConstruct: "phrasing" },
  {
    character: "]",
    inConstruct: ["label", "reference"]
  },
  { atBreak: true, character: "_" },
  { before: "[^A-Za-z]", character: "_", inConstruct: "phrasing" },
  { character: "_", after: "[^A-Za-z]", inConstruct: "phrasing" },
  { atBreak: true, character: "`" },
  {
    character: "`",
    inConstruct: [
      "codeFencedLangGraveAccent",
      "codeFencedMetaGraveAccent",
      "phrasing"
    ]
  },
  { atBreak: true, character: "~" }
];

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options = {}) {
  const context = {
    enter,
    stack: [],
    unsafe: [],
    join: [],
    handlers: {},
    options: {}
  };
  configure(context, { unsafe, join, handlers: handle });
  configure(context, options);
  if (context.options.tightDefinitions) {
    configure(context, { join: [joinDefinition] });
  }
  context.handle = zwitch("type", {
    invalid,
    unknown,
    handlers: context.handlers
  });
  let result = context.handle(tree, null, context, { before: "\n", after: "\n" });
  if (result && result.charCodeAt(result.length - 1) !== 10 && result.charCodeAt(result.length - 1) !== 13) {
    result += "\n";
  }
  return result;
  function enter(name) {
    context.stack.push(name);
    return exit;
    function exit() {
      context.stack.pop();
    }
  }
}
function invalid(value) {
  throw new Error("Cannot handle value `" + value + "`, expected node");
}
function unknown(node) {
  throw new Error("Cannot handle unknown node `" + node.type + "`");
}
function joinDefinition(left, right) {
  if (left.type === "definition" && left.type === right.type) {
    return 0;
  }
}

// ../../node_modules/mdast-util-gfm-autolink-literal/index.js
var inConstruct = "phrasing";
var notInConstruct = ["autolink", "link", "image", "label"];
var gfmAutolinkLiteralToMarkdown = {
  unsafe: [
    {
      character: "@",
      before: "[+\\-.\\w]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    {
      character: ".",
      before: "[Ww]",
      after: "[\\-.\\w]",
      inConstruct,
      notInConstruct
    },
    { character: ":", before: "[ps]", after: "\\/", inConstruct, notInConstruct }
  ]
};

// ../../node_modules/mdast-util-gfm-strikethrough/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing2(parent, context, safeOptions) {
  const children = parent.children || [];
  const results = [];
  let index = -1;
  let before = safeOptions.before;
  while (++index < children.length) {
    const child = children[index];
    let after;
    if (index + 1 < children.length) {
      let handle2 = context.handle.handlers[children[index + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index + 1], parent, context, {
        before: "",
        after: ""
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
    }
    results.push(context.handle(child, parent, context, { before, after }));
    before = results[results.length - 1].slice(-1);
  }
  return results.join("");
}

// ../../node_modules/mdast-util-gfm-strikethrough/index.js
var gfmStrikethroughToMarkdown = {
  unsafe: [{ character: "~", inConstruct: "phrasing" }],
  handlers: { delete: handleDelete }
};
handleDelete.peek = peekDelete;
function handleDelete(node, _, context) {
  const exit = context.enter("emphasis");
  const value = containerPhrasing2(node, context, { before: "~", after: "~" });
  exit();
  return "~~" + value + "~~";
}
function peekDelete() {
  return "~";
}

// ../../node_modules/mdast-util-gfm-table/node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing3(parent, context, safeOptions) {
  const children = parent.children || [];
  const results = [];
  let index = -1;
  let before = safeOptions.before;
  while (++index < children.length) {
    const child = children[index];
    let after;
    if (index + 1 < children.length) {
      let handle2 = context.handle.handlers[children[index + 1].type];
      if (handle2 && handle2.peek)
        handle2 = handle2.peek;
      after = handle2 ? handle2(children[index + 1], parent, context, {
        before: "",
        after: ""
      }).charAt(0) : "";
    } else {
      after = safeOptions.after;
    }
    if (results.length > 0 && (before === "\r" || before === "\n") && child.type === "html") {
      results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, " ");
      before = " ";
    }
    results.push(context.handle(child, parent, context, { before, after }));
    before = results[results.length - 1].slice(-1);
  }
  return results.join("");
}

// ../../node_modules/mdast-util-gfm-table/node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
function patternCompile2(pattern) {
  if (!pattern._compiled) {
    const before = (pattern.atBreak ? "[\\r\\n][\\t ]*" : "") + (pattern.before ? "(?:" + pattern.before + ")" : "");
    pattern._compiled = new RegExp((before ? "(" + before + ")" : "") + (/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? "\\" : "") + pattern.character + (pattern.after ? "(?:" + pattern.after + ")" : ""), "g");
  }
  return pattern._compiled;
}

// ../../node_modules/mdast-util-gfm-table/node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
inlineCode3.peek = inlineCodePeek2;
function inlineCode3(node, _, context) {
  let value = node.value || "";
  let sequence = "`";
  let index = -1;
  while (new RegExp("(^|[^`])" + sequence + "([^`]|$)").test(value)) {
    sequence += "`";
  }
  if (/[^ \r\n]/.test(value) && (/[ \r\n`]/.test(value.charAt(0)) || /[ \r\n`]/.test(value.charAt(value.length - 1)))) {
    value = " " + value + " ";
  }
  while (++index < context.unsafe.length) {
    const pattern = context.unsafe[index];
    const expression = patternCompile2(pattern);
    let match;
    if (!pattern.atBreak)
      continue;
    while (match = expression.exec(value)) {
      let position = match.index;
      if (value.charCodeAt(position) === 10 && value.charCodeAt(position - 1) === 13) {
        position--;
      }
      value = value.slice(0, position) + " " + value.slice(match.index + 1);
    }
  }
  return sequence + value + sequence;
}
function inlineCodePeek2() {
  return "`";
}

// ../../node_modules/markdown-table/index.js
function markdownTable(table2, options) {
  const settings = options || {};
  const align = (settings.align || []).concat();
  const stringLength = settings.stringLength || defaultStringLength;
  const alignments = [];
  let rowIndex = -1;
  const cellMatrix = [];
  const sizeMatrix = [];
  const longestCellByColumn = [];
  let mostCellsPerRow = 0;
  let columnIndex;
  let row;
  let sizes;
  let size;
  let cell;
  let line2;
  let before;
  let after;
  let code2;
  while (++rowIndex < table2.length) {
    columnIndex = -1;
    row = [];
    sizes = [];
    if (table2[rowIndex].length > mostCellsPerRow) {
      mostCellsPerRow = table2[rowIndex].length;
    }
    while (++columnIndex < table2[rowIndex].length) {
      cell = serialize(table2[rowIndex][columnIndex]);
      if (settings.alignDelimiters !== false) {
        size = stringLength(cell);
        sizes[columnIndex] = size;
        if (longestCellByColumn[columnIndex] === void 0 || size > longestCellByColumn[columnIndex]) {
          longestCellByColumn[columnIndex] = size;
        }
      }
      row.push(cell);
    }
    cellMatrix[rowIndex] = row;
    sizeMatrix[rowIndex] = sizes;
  }
  columnIndex = -1;
  if (typeof align === "object" && "length" in align) {
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = toAlignment(align[columnIndex]);
    }
  } else {
    code2 = toAlignment(align);
    while (++columnIndex < mostCellsPerRow) {
      alignments[columnIndex] = code2;
    }
  }
  columnIndex = -1;
  row = [];
  sizes = [];
  while (++columnIndex < mostCellsPerRow) {
    code2 = alignments[columnIndex];
    before = "";
    after = "";
    if (code2 === 99) {
      before = ":";
      after = ":";
    } else if (code2 === 108) {
      before = ":";
    } else if (code2 === 114) {
      after = ":";
    }
    size = settings.alignDelimiters === false ? 1 : Math.max(1, longestCellByColumn[columnIndex] - before.length - after.length);
    cell = before + "-".repeat(size) + after;
    if (settings.alignDelimiters !== false) {
      size = before.length + size + after.length;
      if (size > longestCellByColumn[columnIndex]) {
        longestCellByColumn[columnIndex] = size;
      }
      sizes[columnIndex] = size;
    }
    row[columnIndex] = cell;
  }
  cellMatrix.splice(1, 0, row);
  sizeMatrix.splice(1, 0, sizes);
  rowIndex = -1;
  const lines = [];
  while (++rowIndex < cellMatrix.length) {
    row = cellMatrix[rowIndex];
    sizes = sizeMatrix[rowIndex];
    columnIndex = -1;
    line2 = [];
    while (++columnIndex < mostCellsPerRow) {
      cell = row[columnIndex] || "";
      before = "";
      after = "";
      if (settings.alignDelimiters !== false) {
        size = longestCellByColumn[columnIndex] - (sizes[columnIndex] || 0);
        code2 = alignments[columnIndex];
        if (code2 === 114) {
          before = " ".repeat(size);
        } else if (code2 === 99) {
          if (size % 2) {
            before = " ".repeat(size / 2 + 0.5);
            after = " ".repeat(size / 2 - 0.5);
          } else {
            before = " ".repeat(size / 2);
            after = before;
          }
        } else {
          after = " ".repeat(size);
        }
      }
      if (settings.delimiterStart !== false && !columnIndex) {
        line2.push("|");
      }
      if (settings.padding !== false && !(settings.alignDelimiters === false && cell === "") && (settings.delimiterStart !== false || columnIndex)) {
        line2.push(" ");
      }
      if (settings.alignDelimiters !== false) {
        line2.push(before);
      }
      line2.push(cell);
      if (settings.alignDelimiters !== false) {
        line2.push(after);
      }
      if (settings.padding !== false) {
        line2.push(" ");
      }
      if (settings.delimiterEnd !== false || columnIndex !== mostCellsPerRow - 1) {
        line2.push("|");
      }
    }
    lines.push(settings.delimiterEnd === false ? line2.join("").replace(/ +$/, "") : line2.join(""));
  }
  return lines.join("\n");
}
function serialize(value) {
  return value === null || value === void 0 ? "" : String(value);
}
function defaultStringLength(value) {
  return value.length;
}
function toAlignment(value) {
  const code2 = typeof value === "string" ? value.charCodeAt(0) : 0;
  return code2 === 67 || code2 === 99 ? 99 : code2 === 76 || code2 === 108 ? 108 : code2 === 82 || code2 === 114 ? 114 : 0;
}

// ../../node_modules/mdast-util-gfm-table/index.js
function gfmTableToMarkdown(options) {
  const settings = options || {};
  const padding = settings.tableCellPadding;
  const alignDelimiters = settings.tablePipeAlign;
  const stringLength = settings.stringLength;
  const around = padding ? " " : "|";
  return {
    unsafe: [
      { character: "\r", inConstruct: "tableCell" },
      { character: "\n", inConstruct: "tableCell" },
      { atBreak: true, character: "|", after: "[	 :-]" },
      { character: "|", inConstruct: "tableCell" },
      { atBreak: true, character: ":", after: "-" },
      { atBreak: true, character: "-", after: "[:|-]" }
    ],
    handlers: {
      table: handleTable,
      tableRow: handleTableRow,
      tableCell: handleTableCell,
      inlineCode: inlineCodeWithTable
    }
  };
  function handleTable(node, _, context) {
    return serializeData(handleTableAsData(node, context), node.align);
  }
  function handleTableRow(node, _, context) {
    const row = handleTableRowAsData(node, context);
    const value = serializeData([row]);
    return value.slice(0, value.indexOf("\n"));
  }
  function handleTableCell(node, _, context) {
    const exit = context.enter("tableCell");
    const value = containerPhrasing3(node, context, {
      before: around,
      after: around
    });
    exit();
    return value;
  }
  function serializeData(matrix, align) {
    return markdownTable(matrix, {
      align,
      alignDelimiters,
      padding,
      stringLength
    });
  }
  function handleTableAsData(node, context) {
    const children = node.children;
    let index = -1;
    const result = [];
    const subexit = context.enter("table");
    while (++index < children.length) {
      result[index] = handleTableRowAsData(children[index], context);
    }
    subexit();
    return result;
  }
  function handleTableRowAsData(node, context) {
    const children = node.children;
    let index = -1;
    const result = [];
    const subexit = context.enter("tableRow");
    while (++index < children.length) {
      result[index] = handleTableCell(children[index], node, context);
    }
    subexit();
    return result;
  }
  function inlineCodeWithTable(node, parent, context) {
    let value = inlineCode3(node, parent, context);
    if (context.stack.includes("tableCell")) {
      value = value.replace(/\|/g, "\\$&");
    }
    return value;
  }
}

// ../../node_modules/mdast-util-gfm-task-list-item/node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet2(context) {
  const marker = context.options.bullet || "*";
  if (marker !== "*" && marker !== "+" && marker !== "-") {
    throw new Error("Cannot serialize items with `" + marker + "` for `options.bullet`, expected `*`, `+`, or `-`");
  }
  return marker;
}

// ../../node_modules/mdast-util-gfm-task-list-item/node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent2(context) {
  const style = context.options.listItemIndent || "tab";
  if (style === 1 || style === "1") {
    return "one";
  }
  if (style !== "tab" && style !== "one" && style !== "mixed") {
    throw new Error("Cannot serialize items with `" + style + "` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`");
  }
  return style;
}

// ../../node_modules/mdast-util-gfm-task-list-item/node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow2(parent, context) {
  const children = parent.children || [];
  const results = [];
  let index = -1;
  while (++index < children.length) {
    const child = children[index];
    results.push(context.handle(child, parent, context, { before: "\n", after: "\n" }));
    if (index < children.length - 1) {
      results.push(between(child, children[index + 1]));
    }
  }
  return results.join("");
  function between(left, right) {
    let index2 = context.join.length;
    let result;
    while (index2--) {
      result = context.join[index2](left, right, parent, context);
      if (result === true || result === 1) {
        break;
      }
      if (typeof result === "number") {
        return "\n".repeat(1 + result);
      }
      if (result === false) {
        return "\n\n<!---->\n\n";
      }
    }
    return "\n\n";
  }
}

// ../../node_modules/mdast-util-gfm-task-list-item/node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
var eol2 = /\r?\n|\r/g;
function indentLines2(value, map3) {
  const result = [];
  let start = 0;
  let line2 = 0;
  let match;
  while (match = eol2.exec(value)) {
    one2(value.slice(start, match.index));
    result.push(match[0]);
    start = match.index + match[0].length;
    line2++;
  }
  one2(value.slice(start));
  return result.join("");
  function one2(value2) {
    result.push(map3(value2, line2, !value2));
  }
}

// ../../node_modules/mdast-util-gfm-task-list-item/node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem2(node, parent, context) {
  const listItemIndent = checkListItemIndent2(context);
  let bullet = checkBullet2(context);
  if (parent && parent.ordered) {
    bullet = (typeof parent.start === "number" && parent.start > -1 ? parent.start : 1) + (context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) + ".";
  }
  let size = bullet.length + 1;
  if (listItemIndent === "tab" || listItemIndent === "mixed" && (parent && parent.spread || node.spread)) {
    size = Math.ceil(size / 4) * 4;
  }
  const exit = context.enter("listItem");
  const value = indentLines2(containerFlow2(node, context), map3);
  exit();
  return value;
  function map3(line2, index, blank) {
    if (index) {
      return (blank ? "" : " ".repeat(size)) + line2;
    }
    return (blank ? bullet : bullet + " ".repeat(size - bullet.length)) + line2;
  }
}

// ../../node_modules/mdast-util-gfm-task-list-item/index.js
var gfmTaskListItemToMarkdown = {
  unsafe: [{ atBreak: true, character: "-", after: "[:|-]" }],
  handlers: { listItem: listItemWithTaskListItem }
};
function listItemWithTaskListItem(node, parent, context) {
  const head = node.children[0];
  let value = listItem2(node, parent, context);
  if (typeof node.checked === "boolean" && head && head.type === "paragraph") {
    value = value.replace(/^(?:[*+-]|\d+\.)([\r\n]| {1,3})/, check);
  }
  return value;
  function check($0) {
    return $0 + "[" + (node.checked ? "x" : " ") + "] ";
  }
}

// ../../node_modules/mdast-util-gfm/index.js
function gfmToMarkdown(options) {
  return {
    extensions: [
      gfmAutolinkLiteralToMarkdown,
      gfmStrikethroughToMarkdown,
      gfmTableToMarkdown(options),
      gfmTaskListItemToMarkdown
    ]
  };
}

// lib/serialize.js
function serialize2(tree) {
  return toMarkdown(tree, {
    extensions: [gfmToMarkdown()]
  });
}

// index.js
var line = (0, import_mdast_builder2.html)("<hr/>");
var DECLARATIONS = {
  mixins: "mixins",
  variables: "variables",
  functions: "functions",
  exports: "exports"
};
var SECTIONS = {
  mainHeading: "main-heading",
  superClass: "super-class",
  fields: "fields",
  methods: "methods",
  staticFields: "static-fields",
  staticMethods: "static-methods",
  slots: "slots",
  events: "events",
  attributes: "attributes",
  cssProperties: "css-properties",
  cssParts: "css-parts",
  mixins: "mixins"
};
var declarationHeading = (options) => ({ kind: kind2, name, tagName }) => (0, import_mdast_builder2.heading)(2 + (options?.headingOffset ?? 0), [
  (0, import_mdast_builder2.text)(`${kind2}: `),
  (0, import_mdast_builder2.inlineCode)(name),
  ...tagName ? [
    (0, import_mdast_builder2.text)(", "),
    (0, import_mdast_builder2.inlineCode)(tagName)
  ] : []
]);
var defaultDescriptor = (name) => ({ heading: capital(name), get: (x) => x?.[name] });
var getDescriptor = (x) => typeof x === "string" ? defaultDescriptor(x) : x;
var getColumnWithOptions = (options) => (decls) => ({ heading: heading3, get, cellType = import_mdast_builder2.text }) => ({ heading: heading3, cellType, values: decls.map((x) => get(x, options)) });
var getHeading = (x) => (0, import_mdast_builder2.tableCell)((0, import_mdast_builder2.text)(x.heading));
var getCell = (i) => ({ values, cellType = import_mdast_builder2.text }) => {
  const value = values[i];
  if (!value)
    return (0, import_mdast_builder2.tableCell)((0, import_mdast_builder2.text)(""));
  if (cellType === "raw")
    return (0, import_mdast_builder2.tableCell)(value);
  else
    return (0, import_mdast_builder2.tableCell)(cellType(value ?? ""));
};
var getRows = (columns) => (_, i) => (0, import_mdast_builder2.tableRow)(columns.map(getCell(i)));
var tableWithTitle = (options) => {
  const getColumn = getColumnWithOptions(options);
  return (title, names, _decls, { headingLevel = 3, filter } = {}) => {
    const by = typeof filter === "function" ? filter : options?.private === "hidden" ? not(isPrivate) : options?.private === "details" ? not(or(isPrivate, isProtected)) : identity;
    const decls = (_decls ?? []).filter(by).filter(identity);
    if (!isLengthy(decls))
      return [];
    const columns = names.map(compose(getColumn(decls), getDescriptor));
    const contentRows = decls.map(getRows(columns));
    return [
      (0, import_mdast_builder2.heading)(headingLevel + (options?.headingOffset ?? 0), (0, import_mdast_builder2.text)(title)),
      (0, import_mdast_builder2.table)(repeat(columns.length, null), [
        (0, import_mdast_builder2.tableRow)(columns.map(getHeading)),
        ...contentRows
      ])
    ];
  };
};
function optionEnabled(option) {
  return isDefined(option) && option === true;
}
function getOmittedConfig(type, omittedOptions) {
  const target = type === "decl" ? Object.assign({}, DECLARATIONS) : Object.assign({}, SECTIONS);
  Object.keys(target).forEach((omitted) => target[omitted] = !omittedOptions.includes(target[omitted]));
  return target;
}
function filteredDeclarations(declarationsToFilter, ommitedDeclarations, classNameFilter) {
  const actualClassNameFilter = classNameFilter instanceof Function ? new RegExp(classNameFilter()) : new RegExp(classNameFilter);
  return declarationsToFilter.filter((decl) => {
    if (kindIs("class")(decl)) {
      return actualClassNameFilter.test(decl.name);
    } else if (kindIs("mixin")(decl)) {
      return isDefined(ommitedDeclarations.mixins) && ommitedDeclarations.mixins === true;
    } else if (kindIs("variable")(decl)) {
      return isDefined(ommitedDeclarations.variables) && ommitedDeclarations.variables === true;
    } else if (kindIs("function")(decl)) {
      return isDefined(ommitedDeclarations.functions) && ommitedDeclarations.functions === true;
    }
    return keepDeclaration.every((result) => result === true);
  });
}
function makeModuleDoc(mod, options) {
  const declarations = mod?.declarations ?? [];
  const exportsDecl = mod?.exports ?? [];
  if (!declarations.length && !exportsDecl.length)
    return;
  const {
    headingOffset = 0,
    classNameFilter = ".*",
    omitSections = [],
    omitDeclarations = []
  } = options ?? {};
  const omittedSections = getOmittedConfig("section", omitSections);
  const omittedDeclarations = getOmittedConfig("decl", omitDeclarations);
  const makeTable = tableWithTitle(options);
  const makeHeading = declarationHeading(options);
  const variablesDecl = filteredDeclarations(declarations, omittedDeclarations, classNameFilter).filter(kindIs("variable"));
  const functionsDecl = filteredDeclarations(declarations, omittedDeclarations, classNameFilter).filter(kindIs("function"));
  return [
    optionEnabled(omittedSections.mainHeading) ? (0, import_mdast_builder2.heading)(1 + headingOffset, [(0, import_mdast_builder2.inlineCode)(mod.path), (0, import_mdast_builder2.text)(":")]) : null,
    ...filteredDeclarations(declarations, omittedDeclarations, classNameFilter).flatMap((decl) => {
      const { kind: kind2, members = [] } = decl;
      const fieldsDecl = members.filter(and(kindIs("field"), not(isStatic)));
      const methodsDecl = members.filter(and(kindIs("method"), not(isStatic)));
      const staticFieldsDecl = members.filter(and(kindIs("field"), isStatic));
      const staticMethodsDecl = members.filter(and(kindIs("method"), isStatic));
      const nodes = [
        !["mixin", "class"].includes(kind2) ? null : makeHeading(decl),
        ...optionEnabled(omittedSections.superClass) ? makeTable("Superclass", [NAME, "module", "package"], [decl.superclass]) : [],
        ...optionEnabled(omittedSections.mixins) ? makeTable("Mixins", [NAME, "module", "package"], decl.mixins) : [],
        ...kind2 === "mixin" && optionEnabled(omittedSections.mixins) ? makeTable("Parameters", [NAME, TYPE, DEFAULT, "description"], decl.parameters) : [],
        ...optionEnabled(omittedSections.staticFields) ? makeTable("Static Fields", [NAME, "privacy", TYPE, DEFAULT, "description", INHERITANCE], staticFieldsDecl) : [],
        ...optionEnabled(omittedSections.staticMethods) ? makeTable("Static Methods", [NAME, "privacy", "description", PARAMETERS, RETURN, INHERITANCE], staticMethodsDecl) : [],
        ...optionEnabled(omittedSections.fields) ? makeTable("Fields", [NAME, "privacy", TYPE, DEFAULT, "description", INHERITANCE], fieldsDecl) : [],
        ...optionEnabled(omittedSections.methods) ? makeTable("Methods", [NAME, "privacy", "description", PARAMETERS, RETURN, INHERITANCE], methodsDecl) : [],
        ...optionEnabled(omittedSections.events) ? makeTable("Events", [NAME, TYPE, "description", INHERITANCE], decl.events) : [],
        ...optionEnabled(omittedSections.attributes) ? makeTable("Attributes", [NAME, ATTR_FIELD, INHERITANCE], decl.attributes) : [],
        ...optionEnabled(omittedSections.cssProperties) ? makeTable("CSS Properties", [NAME, DEFAULT, "description"], decl.cssProperties) : [],
        ...optionEnabled(omittedSections.cssParts) ? makeTable("CSS Parts", [NAME, "description"], decl.cssParts) : [],
        ...optionEnabled(omittedSections.slots) ? makeTable("Slots", [NAME, "description"], decl.slots) : []
      ].filter(identity);
      if (options?.private === "details" && (isLengthy(fieldsDecl.filter(or(isPrivate, isProtected))) || isLengthy(methodsDecl.filter(or(isPrivate, isProtected))))) {
        nodes.push((0, import_mdast_builder2.html)("<details><summary>Private API</summary>"), ...makeTable("Fields", [NAME, "privacy", TYPE, DEFAULT, "description", INHERITANCE], fieldsDecl.filter(or(isPrivate, isProtected)), { filter: identity }), ...makeTable("Methods", [NAME, "privacy", "description", PARAMETERS, RETURN, INHERITANCE], methodsDecl.filter(or(isPrivate, isProtected)), { filter: identity }), (0, import_mdast_builder2.html)("</details>"));
      }
      if (nodes.length)
        nodes.push(line);
      return nodes;
    }),
    ...variablesDecl.length && optionEnabled(omittedDeclarations.variables) ? makeTable("Variables", [NAME, "description", TYPE], variablesDecl, { headingLevel: 2 }) : [],
    ...variablesDecl.length && optionEnabled(omittedDeclarations.variables) ? [line] : [],
    ...functionsDecl.length && optionEnabled(omittedDeclarations.functions) ? makeTable("Functions", [NAME, "description", PARAMETERS, RETURN], functionsDecl, { headingLevel: 2 }) : [],
    ...functionsDecl.length && optionEnabled(omittedDeclarations.functions) ? [line] : [],
    ...optionEnabled(omittedDeclarations.exports) ? makeTable("Exports", [EXPORT_KIND, NAME, DECLARATION, MODULE, PACKAGE], mod.exports, { headingLevel: 2 }) : []
  ].filter(identity);
}
function customElementsManifestToMarkdown(manifest, options) {
  const tree = (0, import_mdast_builder2.root)(manifest.modules.flatMap((x) => makeModuleDoc(x, options)).filter(identity));
  return serialize2(tree);
}
